---
title: 'React Native New Architecture: A Complete Guide'
description: "A deep dive into Fabric, TurboModules, and JSI - the technologies powering React Native's performance revolution"
date: '2024-12-18'
tags: ['react-native', 'mobile', 'architecture', 'performance']
published: true
image: '/blog/react-native-arch.png'
author: 'Harshal Bhavsar'
readingTime: '2 min read'
---

# React Native New Architecture: A Complete Guide

After spending 6+ years building React Native apps at scale, I've witnessed the evolution from the old bridge architecture to the blazing-fast **New Architecture**. Here's everything you need to know.

## What's Changing?

The New Architecture introduces three key components:

1. **Fabric** - A new rendering system
2. **TurboModules** - A new native modules system
3. **JSI** - JavaScript Interface for direct native calls

## The Problem with the Old Bridge

The legacy architecture relied on a **JSON bridge** to communicate between JavaScript and Native:

```javascript
// Old way - everything serialized to JSON
NativeModules.MyModule.doSomething({ data: largeObject })
// This serializes to JSON, crosses the bridge, then deserializes
```

This caused:

- **Serialization overhead** on every call
- **Async-only communication** (no synchronous calls)
- **Memory duplication** across JS and Native

## Enter JSI (JavaScript Interface)

JSI allows JavaScript to hold references to C++ objects and call methods on them **synchronously**:

```typescript
// New way - direct memory access
interface MyModule extends TurboModule {
  multiply(a: number, b: number): number // Synchronous!
  fetchDataAsync(): Promise<string> // Can still be async when needed
}
```

The result? **Up to 10x faster** for synchronous native calls.

## Fabric: The New Renderer

Fabric reimagines how React Native renders UI:

### Before (Old Architecture)

```
JS Thread → Bridge (async) → Shadow Thread → UI Thread
```

### After (Fabric)

```
JS Thread ←→ C++ (synchronous) ←→ UI Thread
```

Key benefits:

- **Concurrent rendering** support
- **Synchronous layout** calculations
- **Improved gesture handling**

## TurboModules: Lazy Loading Native Code

TurboModules bring on-demand loading to native modules:

```typescript
// turbo-module-spec.ts
import { TurboModuleRegistry } from 'react-native'

export interface Spec extends TurboModule {
  getConstants(): { version: string }
  multiply(a: number, b: number): number
}

export default TurboModuleRegistry.getEnforcing<Spec>('Calculator')
```

Benefits:

- **Lazy initialization** - modules load only when first accessed
- **Type safety** - TypeScript specs ensure correct usage
- **Faster startup** - unused modules don't impact launch time

## Migration Strategy

Here's my recommended approach for migrating large apps:

### Phase 1: Enable the New Architecture

```ruby
# ios/Podfile
:fabric_enabled => true,
:new_arch_enabled => true,
```

### Phase 2: Migrate Native Modules

Start with leaf modules that have no dependencies on other native code.

### Phase 3: Update Third-Party Libraries

Check [reactnative.directory](https://reactnative.directory) for New Architecture compatibility.

### Phase 4: Enable in Production

Roll out gradually using feature flags.

## Performance Results from MoneyLion

After migrating our app at MoneyLion:

| Metric             | Before | After | Improvement       |
| ------------------ | ------ | ----- | ----------------- |
| App Launch         | 2.8s   | 1.9s  | **32% faster**    |
| Screen Transitions | 120ms  | 45ms  | **63% faster**    |
| Memory Usage       | 180MB  | 145MB | **20% reduction** |

## Conclusion

The New Architecture is production-ready. If you're starting a new React Native project, enable it from day one. For existing apps, plan your migration now - the performance benefits are worth it.

---

*Have questions about migrating to the New Architecture? [Reach out on X](https://x.com/harshalb_) - I'm happy to help!*
